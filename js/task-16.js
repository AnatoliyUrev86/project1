// МОДУЛЬ 10 ЗАНЯТТЯ 2
// Як нам самостійно створити Проміс для робоити з Асинхронним кодом
// const promise = new Promise((resolve, reject) => {
//   const random = Math.random();
//   setTimeout(() => {
//     if (random > 0.5) {
//       resolve("ok");
//     } else {
//       reject("ops");
//     }
//   }, 2000);
// });
// promise
//   .then((resolve) => {
//     console.log("then", resolve);
//   })
//   .catch((error) => {
//     console.log("catch", error);
//   })
//   .finalli(() => {
//     console.log("promise");
//   });

// Щоб створити проміс для роботи з асинхронним кодом створюємо змінну promise ми звертаємось до класу Promise
// І створюємо його екземпляр new Promise як параметри в круглі дужки передаємо стрілочну функцію яка буде
// приймати в себе два методи (resolve, reject)
// random - змінна яка буде генерувати в себе якесь випадкове число
// Щоб написати в середині промісу асинхронний код звертаємось до методу setTimeout
// І в ньму за допомогою циклів if та else будемо перевіряти виконання або не виконання нашого промісу
// Метод resolve - відповідає за виконання нашого промісу і в середину передаємо данні які ми хочемо отримати
// при успішному виконанні нашого промісу "ok"
// Метод reject - відповідає за не виконання нашого промісу і в середину передаємо данні які ми хочемо отримати
// при не виконанні нашого промісу "ops" тобто помилки
// У консолі отримує мо Проміс pending - це означає що він очікує на результат
// Після ще одного оновлення консолі ми отримуємо стан Промісу fulfilled - це успашне виконання промісу тому що
// спрацював метод resolve
// Після ще одного оновлення консолі ми отримуємо "rejected" - для виконання Промісу з помилкою і переведення його
// в стан rejected
// Для того щоб обробляти результат виконання нашого Промісу promise є метод .then() - цей метод буде чекати доки наш
// Проміс завершиться успіхом він буде отримувати результат "ok" і обробляти його він приймає в себе колбек функцію
// Ця функція приймає в себе як параметр успішне виконання нашого промісу resolve
// Тепер викликаємо метод який буде обробляти помилку .catch він приймає в себе колбук функцію а функція буде
// отримувати значення яке буде при помилці нашого промісу "ops"
// .finalli() - даний метод виконується в будь якому випадку не залежно від того як наш проміс виконається
// успішно чи помилкою він так само приймає колбек функцію
// але без параметрів тому що ми не знаємо чим завершиться наш промі успшно чи помилкою
// Також має бути дотримана послідовність скільки б методів не було по кількості
// 1-й має бути  .then 2-й має бути .catch 3-й має бути .finalli

// СТВОРЕННЯ ЛАНЦЮЖКІВ ДЛЯ promise
// const promise = new Promise((resolve, reject) => {
//   setTimeout(() => {
//     resolve(5);
//   }, 1000);
// });
// promise
//   .then((res) => {
//     return res * 2;
//   })
//   .then((data) => {
//     console.log(data);
//   })
//   .catch((err) => {
//         console.log(err);
//       })

// З методу then завжди буде повертатися promise і загорнуте в нього значення res * 2 для того щоб обробити
// цей результат promise тобто res * 2 ми створюємо ще один метод then де буде оброблятися результат
// Таким чинов вибудовується наш ланцюжок promise

// Promise - це  об'єкт який повертає поточний стан нашого Асинхроного коду він приймає в себе колбек функцію яка
// в свою чергу приймає в себе два параметри resolve - відповідає за умову коли проміс виконується і має стан
// очікування pending потім стан виконання fulfilled
// reject - відповідає за виконання промісу коли помилка і отрмання стану rejected
// .finalli() - подія яка виконується в будь якому випадку не залежить від того чи проміс виконається чи
// буде помилка

// У НАС Є ДВАВИДИ АСИНХРОННОГО КОДУ ЯКИЙ МАЄ МІКРО ТА МАКРО ПРОЦЕСИ
// ДО МІКРО ПРОЦЕСІВ - проміси promise слухач подій addEventListener та Обсервер на який ми будемо дивитися
// ДО МАКРО ПРОЦЕСІВ ВІДНОСЯТЬСЯ -  setTimeout та setInterval
// Під час виконання у нас буде виконуватися Асинхронний код

console.log("step 1");

setTimeout(() => {
  console.log("step 2");
}, 0);

new Promise(() => {
  resolve("step 3");
}).then((data) => console.log(data));
setTimeout(() => {
  console.log("step 3");
}, 0);

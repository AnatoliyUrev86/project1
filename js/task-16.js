// МОДУЛЬ 10 ЗАНЯТТЯ 2
// Як нам самостійно створити Проміс для робоити з Асинхронним кодом
const promise = new Promise((resolve, reject) => {
  const random = Math.random();
  setTimeout(() => {
    if (random > 0.5) {
      resolve("ok");
    } else {
      reject("ops");
    }
  }, 2000);
});
promise
  .then((resolve) => {
    console.log("then", resolve);
  })
  .catch((error) => {
    console.log("catch", error);
  });

// Щоб створити проміс для роботи з асинхронним кодом створюємо змінну promise ми звертаємось до класу Promise
// І створюємо його екземпляр new Promise як параметри в круглі дужки передаємо стрілочну функцію яка буде
// приймати в себе два методи (resolve, reject)
// random - змінна яка буде генерувати в себе якесь випадкове число
// Щоб написати в середині промісу асинхронний код звертаємось до методу setTimeout
// І в ньму за допомогою циклів if та else будемо перевіряти виконання або не виконання нашого промісу
// Метод resolve - відповідає за виконання нашого промісу і в середину передаємо данні які ми хочемо отримати
// при успішному виконанні нашого промісу "ok"
// Метод reject - відповідає за не виконання нашого промісу і в середину передаємо данні які ми хочемо отримати
// при не виконанні нашого промісу "ops" тобто помилки
// У консолі отримує мо Проміс pending - це означає що він очікує на результат
// Після ще одного оновлення консолі ми отримуємо стан Промісу fulfilled - це успашне виконання промісу тому що
// спрацював метод resolve
// Після ще одного оновлення консолі ми отримуємо "rejected" - для виконання Промісу з помилкою і переведення його
// в стан rejected
// Для того щоб обробляти результат виконання нашого Промісу promise є метод .then() - цей метод буде чекати доки наш
// Проміс завершиться успіхом він буде отримувати результат "ok" і обробляти його він приймає в себе колбек функцію
// Ця функція приймає в себе як параметр успішне виконання нашого промісу resolve
// Тепер викликаємо метод який буде обробляти помилку .catch він приймає в себе колбук функцію а функція буде
// отримувати значення яке буде при помилці нашого промісу "ops"
